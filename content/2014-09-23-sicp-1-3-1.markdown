Title: sicp 1.3.1
Slug: sicp-1-3-1
Date: 2014-09-23 22:21:05 
Modified: 2014-09-23 22:21:05 
Category: blog
Tags: sicp

# 导读
也许我们曾经在某个场合听说过这些术语：“函数式语言”、“函数式编程范式”、“纯函数式语言”。在阅读sicp之前我对这些术语也只是“不明觉厉”。

一般而言，如果一种编程语言允许函数成为“第一等公民”(first class object)，我们就可以将这类语言归为“函数式语言”。本书介绍了函数作为“第一等公民”所拥有的特权：

* 可以用变量命名
* 可以作为参数传递
* 可以作为函数返回值
* 可以包含在数据结构中

由此可见，本书采用的scheme是函数式语言，而c/c++/java等不是函数式语言。本节展示了如何将函数作为参数传递，同时也展示了将函数作为参数传递的巨大威力。

# 习题解答
* 练习1.29

``` Scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (simpson-integral f a b n)
  (let ((h (/ (- b a) n)))
    (define (simpson-term k)
      (* (f (+ a (* k h)))
         (cond ((or (= 0 k) (= n k)) 1)
               ((odd? k) 4)
               (else 2))))
    (* (/ h 3.0) (sum simpson-term 0 (lambda(x) (+ x 1)) n))))

(simpson-integral cube 0 1 100)
=> 0.25
(simpson-integral cube 0 1 1000)
=> 0.25
```

* 练习1.30

``` Scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (+ (term a) result))))
  (iter a 0))
```

* 练习1.31

product过程的递归实现:
``` Scheme
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))

```
用product定义factorial:
``` Scheme
(define (factorial n)
  (product (lambda (x) x)
           1
           (lambda (x) (+ x 1))
           n))
```
product过程的迭代实现:
``` Scheme
(define (product term a next b)
  (define (iter i result)
    (if (> i b)
        result
        (iter (next i)
              (* (term i) result))))
  (iter a 1))
```
* 练习1.32

``` Scheme
;递归版本
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))

;迭代版本
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (combiner (term a)
                        result))))
  (iter a null-value))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))
```