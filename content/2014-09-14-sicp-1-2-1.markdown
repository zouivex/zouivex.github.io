Title: sicp 1.2 (1)
Slug: sicp-1-2-1
Date: 2014-09-14 10:51:40
Modified: 2014-09-14 10:51:40
Category: blog
Tags: sicp, lisp

# 导读

要想真正理解Scheme语言，必须要深刻理解“递归”和“迭代”两个概念。目前国内的计算机专业都是采用c语言作为入门编程语言。学习c语言的时候，我们知道模块化编程的基本结构是“顺序”、“分支”和“循环”。甚至有人证明只需要用这3种结构就足以表达所有程序。在Scheme语言中则不然，通过本书的学习，我们可以得出结论：循环结构只是递归结构的一种”语法糖“。

本节还需要理解的一个”尾递归“的概念。通过”尾递归“优化可以实现循环结构。Scheme的IEEE标准要求Scheme解释器必须实现”尾递归“，因此在Scheme语言中循环结构不是必须的。我们熟知的c语言就不是”尾递归“的，因此在c语言中特殊的循环结构（如for, while...）是必不可少的。

# 习题解答

* 练习1.9

第一个过程是递归的。我们可以通过trace查看(plus 4 5)的递归调用过程。

``` Scheme
(plus 4 5)
|  (dec 4)
|  3
|  (plus 3 5)
|  |  (dec 3)
|  |  2
|  |  (plus 2 5)
|  |  |  (dec 2)
|  |  |  1
|  |  |  (plus 1 5)
|  |  |  |  (dec 1)
|  |  |  |  0
|  |  |  |  (plus 0 5)
|  |  |  |  5
|  |  |  (inc 5)
|  |  |  6
|  |  (inc 6)
|  |  7
|  (inc 7)
|  8
(inc 8)
9
```

第二个过程是迭代的。下面是(plus 4 5)的迭代调用过程。

``` Scheme
(plus 4 5)
|  (dec 4)
|  3
|  (inc 5)
|  6
(plus 3 6)
|  (dec 3)
|  2
|  (inc 6)
|  7
(plus 2 7)
|  (dec 2)
|  1
|  (inc 7)
|  8
(plus 1 8)
|  (dec 1)
|  0
|  (inc 8)
|  9
(plus 0 9)
9
```

* 练习1.11

``` Scheme
;;递归过程
(define (f n)
	(if (< n 3)
		n
		(+ (f (- n 1))
		   (* 2 (f (- n 2)))
		   (* 3 (f (- n 3))))))
```

* 练习1.12

``` Scheme
(define (pascal-triangle row col)
  (cond ((= row 1) 1)
        ((= row col) 1)
        ((= col 1) 1)
        (else
          (+ (pascal-triangle (- row 1) col)
             (pascal-triangle (- row 1) (- col 1))))))
```

* 练习1.15

1. 在求值(sine 12.15)时，p将被使用5次.
``` Scheme
(sine 12.15)
|  (abs 12.15)
|  12.15
|  (sine 4.05)
|  |  (abs 4.05)
|  |  4.05
|  |  (sine 1.3499999999999999)
|  |  |  (abs 1.3499999999999999)
|  |  |  1.3499999999999999
|  |  |  (sine 0.44999999999999996)
|  |  |  |  (abs 0.44999999999999996)
|  |  |  |  0.44999999999999996
|  |  |  |  (sine 0.15)
|  |  |  |  |  (abs 0.15)
|  |  |  |  |  0.15
|  |  |  |  |  (sine 0.049999999999999996)
|  |  |  |  |  |  (abs 0.049999999999999996)
|  |  |  |  |  |  0.049999999999999996
|  |  |  |  |  0.049999999999999996
|  |  |  |  (p 0.049999999999999996)
|  |  |  |  |  (cube 0.049999999999999996)
|  |  |  |  |  1.2499999999999998e-4
|  |  |  |  0.1495
|  |  |  (p 0.1495)
|  |  |  |  (cube 0.1495)
|  |  |  |  0.003341362375
|  |  |  0.4351345505
|  |  (p 0.4351345505)
|  |  |  (cube 0.4351345505)
|  |  |  0.08238927958303073
|  |  0.9758465331678772
|  (p 0.9758465331678772)
|  |  (cube 0.9758465331678772)
|  |  0.9292756784936136
|  -0.7895631144708228
(p -0.7895631144708228)
|  (cube -0.7895631144708228)
|  -0.4922214714997821
-0.39980345741334
```

2. 求值(sine a)时，空间增长的阶为O(n)，计算时间增长的阶为O(log(n)).

* 练习1.16

``` Scheme
(define (fast-expt-iter b n)
  (define (iter i a)
    (if (= i 0)
        a
        (if (even? i)
            (iter (/ i 2) (square a))
            (iter (- i 1) (* b a)))))
  (iter n 1))
```

* 练习1.17

``` Scheme
(define (fast-product a b)
  (if (= b 0)
      a
      (if (even? b)
          (double (fast-product a (halve b)))
          (+ a (faslt-product a (- b 1))))))
```

* 练习1.18

``` Scheme
(define (fast-product-iter a b)
  (define (iter i result)
    (if (= i 0)
        result
        (if (even? i)
            (iter (halve i) (double result))
            (iter (- i 1) (+ a result)))))
  (iter a 0))
```

* 练习1.19

``` Scheme
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))     ; p'
                   (+ (* 2 p q) (* q q))   ; q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(define (fib n)
  (fib-iter 1 0 0 1 n))
```
